# Stating Analysis in Linux
- **Key Points:**
    - no execution
    - careful view of: malware code / data / structure

    - Key Info:
        - File Type / File Hash / Strings / Embedded Elements
        - Packer Info
        - Import Functions
        - Export Functions
        - Assembly Code

- **Identify File Type:**
    - `file` command
    - `hexdump` command >> `hexdump -C /file_path`
        - **MZ** ASCII String >> hexvalue: `4D 5A` >> at the start of file
        - This tells >> *Windows Executable File*
        - *MZ* >> Mark Zbikowski, a key architect of MS-DOS

- **Malware Fingerprinting:**
    - unique identifier
    - Hashes: SHA128 >> SHA256 >> MD5
        - `md5sum file` >> `sha256sum file`

    - File Hash LookUp:
        - `VirusTotal` >> for the same hash >> could be different names
        - `Cuckoo Sandbox`

- **Import Hashing (IMPHASH)**
    - It hashes only the **list of the imported DLL functions** in the Portable Executable file (PE file)
        - **Its Algorithm:**
            - Converts all imported functions' names to lowercase
            - The DLL & function names are fused together and arranged in alphabetical order.
            - Then, MD5 hash is generated
            -
        - **Goal here** >> sometimes content could be different (on purpose by attacker)
            - But the import functions may not change, hoping on that
            - Later compare two PE files >> if IMPHASH of them match >> then they may be same
            -
        - IMPHASH Calculate
            - Python Module `pefile`
                - refer to the `imphash_calc.py` in the curr directory

- **Fuzzy Hashing: (SSDEEP)**
    - context-triggered piecewise hashing
    - compute a hash value >> to show **content similarity between two files**

    - Its Algorithm: divides the file into chunks >> then takes the hash for each chunk
        - These block chunks come together to give *the final fuzzy hash*

    - Example Tool: `ssdeep`
        - `ssdeep file_name`
        -
        - Matching Mode:
            - `ssdeep -pb *` >> shows what malware files can share similar contents
                - `-p` >> pretty matching mode
                - `-b` >> to show only file name without full path

- **Section Hashing: (Hasing PE Sections)**
    - individual sections of PE will be hashed
    - more low-level/careful approach

    - Tool: `pefile`
        - refer to the `section_hashing.py` in the directory

    - Could be bypassed as well
        - By obfuscating section names
        - dynamically-generated section names

- **String Analysis:**
    - To extract `ASCII & Unicode` strings from binary

    - What we can get:
        - Embedded file names
        - IP addresses / Domain names
        - Registry Path / Keys
        - WinAPI functions
        - Commandline args

    - Tool#1: `strings` >> *Extracts plain ASCII/Unicode text*
        - `strings -n 15 file_name`

    - Tool#2: `floss` >> *Extracts hidden strings (e.g. decoded at runtime)*
        - `floss file_name`

- **Unpacking UPX-packed Malware:**
    - `Packing` Technique:
        - compresses & decodes & encodes **original code**
        - puts this in `stub` >> small loader code
        - then `stub` runs >>
        - this `stub` (additional code) >> unpacks the real code at runtime `in memory` & `executes it`

    - Goals:
        - signatures are hidden
        - code is unpacked in memory, not visible on disk
        - harder for reverse-engineering
        - harder to be detected by signature-based tools >> signature is hidden

    - How to Detect:
        - `Entropy` Analysis
            - Entropy >> shows the randomness quality of the written program
            - Each section of the executable file has `entropy` indicatives
            - **Higher value of `entropy` is suspicious for us**
                - means that the data is encrypted or decoded
        - Packer Detecter Tools

    - Process:
        - `upx hello.exe` >> to pack >> can be multiple times
        - `upx -d -o unpacked.exe hello.exe` >> to unpack the packed file

    - Idea:
        - whenever you analyse the file >> if you see artifacts `UPX`
        - it's flag that it's packed >> need to unpack it for better analysis

- **Practical Challenges:**
    1. In the /home/htb-student/Samples/MalwareAnalysis directory of this section's target, there is a file called potato.exe.
       Compute the IMPHASH of this file and submit it as your answer.

    **Solved:**
    - J'ai utilise le script `imphash_calc.py` using `pefile` Python Module
    - Cette commande: `python3 imphash_calc.py potato.exe`
    - Voila, j'ai obtenu le drapeau


# Static Analysis on Windows
- **Identify File Type:**
    - Tool: `CFF Explorer`  >> `MZ` ASCII String >> `4D 5A` >> shows PE files

- **Malware Fingerprinting:**
    - Tool: `Get-FileHash` Powershell cmdlet
        - `Get-FileHash -Algorithm MD5 file_name`

- **IMPHASH:**
    - `IMPHASH` >> the same process to calculate with `pefile` python module
    - `imphash_calc.py` >> refer to this file

- **Fuzzy Hashing:**
    - `ssdeep.exe` works in windows as well
    - to find similar-contents between malware files through hashing technique

- **Section Hashing:**
    - Tool: `pestudio` >> `fingerprints` part shows hashes for certain sections of PE file
    - `section_hashing.py` >> refer to this as well `pefile`

- **String Analysis:**
    - Tool: `strings.exe`  >> works in win
    - `floss.exe` >> also works

- **Unpacking UPX files:**
    - The same process as Linux: `upx.exe` works

    - Tool: `CFF Explorer` >> can show `Section Headers` where you see `UPX` artifacts if packed

- **Practical Challenges:**
    1. In the C:\Samples\MalwareAnalysis directory of this section's target, there is a file called dharma_sample.exe.
       Calculate the file's SHA256 hash and enter it as your answer.

    **Solved:**
    - J'ai utilise cette commande: `Get-FileHash -Algorithm SHA256 dharma_sample.exe`
    - Et Voila, j'ai obtenu le drapeau

























