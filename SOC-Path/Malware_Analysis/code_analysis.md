# Reverse Engineering & Code Analysis
- Goals:
    - analysis of compiled program, binary
    - identify purpose / functionality
    - find potential IoCs >> Incident of Comprises

- Tools:
    - Disassemblers >> `IDA, Cutter, Ghidra`
    - Debuggers >> `x32dbg, x64dbg, IDA, and Ollydbg`

- Key Info:
    - Disassembler >> converts from `Executable Machine Code` to `Assembly Code`

## Code Analysis Example:
- Tool:
    - IDA

- IDA Env:
    1. Import Malware Simple into IDA
    2. `IDA View` >> shows the graph >> control flow
        - This graph shows the order of how functions of this executable are executed
        - The order is solely based on .exe
        -
        - **Arrows:**
            - Solid Arrow (->) >> shows unconditional jump
            - Dashed Arrow (---->) >> shows conditional jump
        -
    3. To switch to `Text View` > press `spacebar` button
        - `section name:virtual address format` >> for example, `.text:00000000004014F0`
    4. Possible to see `Each Function Graph Connection with others`
        - `right-click` >> `Xrefs graph to... or Xrefs graph from...,`

- How To Recognize Main Function?:
    - initial function shown by IDA is not likely the main function


    - Best Strategies:
        - Need to understand the code flow
        - Investigate each `call function_name` >> especially look for what's done up to this function:
            - stack frame creation / allocation / local variables
        - If you see `WinAPI` >> research it individually >> understand by google what `args` this function should take
            - This makes easier to understand the actions taken up to this function
            - Follow the flow >> keep an eye on usual `API Calls`
        - Name the functions by yourself for clarity
        - Keep an eye on local variables
        - Understand the `job / function` of `key assembly codes`
        - Collect IoCs

    - API Call Example:
        - `xor     r8d, r8d        ; ulOptions
        - mov     [rsp+148h+cbData], 100h
        - mov     [rsp+148h+phkResult], rax ; phkResult
        - mov     r9d, 20019h     ; samDesired
        - lea     rdx, aSoftwareVmware ; "SOFTWARE\\VMware, Inc.\\VMware Tools"
        - mov     rcx, 0FFFFFFFF80000002h ; hKey
        - call    cs:RegOpenKeyExA` >> this is **RegOpenKeyExA** WinAPI
        -
    - API Call Function(Original):
        - `LSTATUS RegOpenKeyExA(
        - [in]           HKEY   hKey,
        - [in, optional] LPCSTR lpSubKey,
        - [in]           DWORD  ulOptions,
        - [in]           REGSAM samDesired,
        - [out]          PHKEY  phkResult
        - );`

    - Key Info:
        - `RegOpenKeyExA >> is part of Win Registry API`
        - `utilized to open a handle to a specified registry key`
        - **Handle** >> numeric reference  or identifier to access a resource
        - function enables access to the Windows registry
        - *A in the function name signifies that it is the ANSI version of the function*
        - `cs` >> code segment
        - *RegOpenKeyExA function is imported from an external library (advapi32.dll), with its address stored in the .idata section for future use.*
        - But, this is  not the actual address of the RegOpenKeyExA function
        - >> it is the address of the entry in the `IAT (Import Address Table)` for RegOpenKeyExA.
        - This `IAT` houses the address that will be dynamically resolved `at runtime `
            - point to the actual function implementation in the respective DLL (in this case, advapi32.dll).
        - **extrn RegOpenKeyExA:qword indicates that RegOpenKeyExA is an external symbol**
            - `the linker` will handle resolution of this address during linking process

    - Assembly Code:
        - `rep stosq` >> nullifies the memory
        - `lea rax, [rsp+148h+hKey]` >> loading hkey address to the rax
            - rsp+148h+hKey >> before this, we expanded stack by `sub rsp 140h` then to calculate
                the hkey position >> it is adding the value of current rsp(8) + 140 = 148 so that it
                goes back then hkey = - 128h >> at the end of this calculation, we got [rsp+20] >>
                that's where hkey is stored

## Practical Challenges:
1. Download additional_samples.zip from this module's resources (available at the upper right corner) and
   transfer the .zip file to this section's target. Unzip additional_samples.zip (password: ) and
   use IDA to analyze orange.exe. Enter the registry key that it modifies for persistence as your answer.

   **Solved:**
   - J'ai utilise l'outil >> IDA >> shared folder avec le target
   - Le moment cle est de analyser chaque 'call function_name'
   - J'ai trouve le Registry Key avec un format super complexe:
        -  comme ca: 'Soft%s_bla_%s_bla_%s_bla_'
        -  J'ai donne un nom pour cette function: `GetGremlinRegistryKey`
   - Voila, J'ai obtenu le drapeau

2. Download additional_samples.zip from this module's resources (available at the upper right corner) and
   transfer the .zip file to this section's target. Unzip additional_samples.zip (password:) and
   use IDA to analyze orange.exe. Enter the name of the function that is holding the name of the
   file intrenat.exe that orange.exe drops as your answer.

   **Solved:**
   - J'ai trouve le call function
   - Et Voila, j'ai trouve le file avec telle style: chaque byte est pushed individeulement
   - `intrenat.exe` >>  voila c'est fini >> `407A_3` >>


# Debuggers

## Simulating Internet Serives:
- Process:
    - `INetSim` >> supports different services: DNS, HTTP, FTP, SMTP, among othe
    - In different VM than controlled one >> in sandbox env, you configure it >> you fool the malware.exe

    - `sudo vim /etc/inetsim/inetsim.conf`
        - change:
            - `service_bind_address <Our machine's/VM's TUN IP>`
            - `dns_default_ip <Our machine's/VM's TUN IP>`
            - `dns_default_hostname www`
            - `dns_default_domainname iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com`
    - `sudo inetsim ` >> initiate the tool >> it is running now >> it immitates the real internet services >> your victim feels it

    - **Also, configure the controlled VM to use the custom DNS server now >>**
        - `Control Panel > Network and Internet > Network Connections > Ethernet Properties >>
            Internet Protocol Version 4 >> change here DNS to custom one by giving an IP of it`

## Applying Patches to Malware
- Goal
    - Change some internal workings of the malware to see what it does in its ideal situtation
    - do this with `x64dbg`

    - How to search certain strings, memory addresses
        - `copy direct address from IDA`
            - `right-click >> Go to >> Expressions >> put the address`
        - `strings references`
            - `right-click >> search for >> this module >> String References`

    - Use Breakpoints
    - Change Values >> Assembly Codes >> You can edit them in `x64dbg`
    - Play with conditions >> make them to work for you >> for that >> understand them
    - Save `Patched Version` >> to avoid future redoings

## Analyse Malware Traffic
- Process
    - Run `Wireshark` while running malware
    - See what it does
    - Check & Follow: http, tcp

    - You see that `INetSim` works pretty fine huh?

## Analyzing Process Injection & Memory Region
- Process:
    - Go to `Symbols` Tab
    - *search for the desired DLL name on the left and function names,
    - such as VirtualAllocEx, WriteProcessMemory, and CreateRemoteThread, on the right within the Kernel32.dll DLL*
    -
    - Put a breakpoint them

## Attaching Another Running Process In x64dbg
- Process:
    - start new instance of `x64dbg`
        - `File >> Attach >> choose the running process here`
    - See >> take the memory address given to the second process >> shellcode address maybe
    - Come to the second process >> search for this given memory address
    - See its `HeX` >> you see the shellcode


## Practical Challenges:
1. Reproduce all the debugging procedures mentioned in this section and
   provide the hidden shellcode-related hex values from the final screenshot as your answer. Remove all spaces.

   **Solved:**
   - Apres tout les processes au-dessus, c'est clair comment d'obtain le drapeau
   - Voila, j'ai obtenu ca! `Shellcode == FC4883E4F0E8C0000000415141`

