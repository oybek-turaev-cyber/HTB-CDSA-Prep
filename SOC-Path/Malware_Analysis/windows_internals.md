# What is Malware Analysis?
1. Malware >> malicious software

    - Types:
        - Droppers >> to exfiltrate data
        - Information Stealers
        - Rootkits >> kernel-level >> gain unauthorized access >> hide its presence
    - Malware Samples:
        - Idea is that >> run them in sandboxes, test them, learn how they spread & work
        - TheZoo/ VirusShare/ ANY.RUN / VX Underground/

2. Malware / Evidence Acquisition

    - Disk Imaging Tools:
        - `FTK Imager` >> image copier, view data without altering
        - `OSFClone` >> create / clone disk images
        - `DD` >> command-line / Unix-based utility /included
        - `DCFLDD` >> enhanced version of `DD`: for forensics >> via hashing

    - Memory Acquisition Tools:
        - `DumpIt` >> Win & Lin >> physical memory > into a single output file
        - `MemDump` >> capture system's RAM >>
        - `Belkasoft RAM Capturer` >> Windows >> works even if anti-debugging, anti-dumping protection exist
        - `LiME` >> Linux Memory Extractor >> Loadable Kernel Module (LKM) >> to avoid many anti-forensic measures

    - Other Tools:
        - `KAPE` >> a triage program >> faster & effective
        - `Velociraptor` >> tool designed for host-based incident response and digital forensics >> it has Query language

3. Purposes of Malware Analysis:

    - Detection & Classification
    - Reverse Engineering
    - Behavioral Analysis
    - Threat Intelligence

4. Techniques of Analysis:
    - Static Analysis
    - Dynamic Analysis
    - Code Analysis
        - >> Reverse Engineering >> Disassembling / Decompiling
    - Memory Analysis
        - >> How malware works with system memory
    - Malware Unpacking
        - >>  extracting and isolating the hidden malicious code
        - when it uses packing techniques to evade detection
        - Packers >> used to compress/ encrypt/ obfuscate malicious code
            - Goal >> make it harder for antivirus software and other security tools to identify the threat

# Windows Internals
- Two Modes:
    - User Mode    >> apps & user processes operate >> connect to OS & hardware through WinAPI
    - Kernel Mode  >> highly privileged mode >> direct access to hardware/resources/drivers

- ![Alt text](https://github.com/oybek-turaev-cyber/HTB-CDSA-Prep/blob/main/SOC-Path/Malware_Analysis/pic1.webp)

## User-Mode Components
- System Support Processes:
    - they are not usual windows services
    - but they are launched in boot time earlier
    - they are crucial for proper working of the **system**
    - they are: `winlogon.exe,` Session Manager: `smss.exe`,
        - Service Control Manager: `services.exe`

- Service Processes:
    - Windows services
    - Examples: windows update / task scheduler / print spooler services
    - they have configurations and they work based on them
    - they are optional

- User Applications:
    - they access to OS & hardware by `Windows APIs `
    - Then these APIs internally access to `NTDLL.DLL`
    - the job of `NTDLL.DLL` is to **perform transition from user mode to kernel mode**
    - then system calls function to finish the task further and

- Environment Subsystems:
    - they provide execution env for certain apps or processes
    - for example `Win32 Subsystem`, `POSIX`, `OS/2`
        - `Win32 Subsystem` >> it holds the common Win apps: notepad, MS Office
            -
        - `POSIX` >> deprecated >> allows Unix-like apps to run on Windows
            - now it is replaced by `Windows Subsystem for Linux` **WSL**
            -
        - `OS/2` >>  OS co-developed by IBM and Microsoft in the late 1980s before Windows 3.0
            - it had Text-based, 16-bit applications
            - Command Line Tools – like `cmd, dir, copy`

- Subsystem DLLs:
    - easy, high-level functions for developers.
    - provide a friendly API >> abstracts complexity
    - then talks to `NTDLL.DLL`
    - examples: `kernelbase.dll, user32.dll, wininet.dll, and advapi32.dll.`


## Kernel Mode Components

- Executive:
    - gets accessed through functions from NTDLL.DLL
    - components: `I/O Manager, Object Manager, Security Reference Monitor, Process Manager`
    - **runs some checks first, and then passes the call to kernel**
    - **calls the appropriate device driver to perform the requested operation**

- Kernel
    - manages system resources, providing low-level services
        - `thread scheduling, interrupt and exception dispatching, and multiprocessor synchronization.`

- Device Drivers:
    - *These software components enable the OS to interact with hardware devices*

- HAL >> Hardware Abstraction Layer
    -  abstraction layer between the hardware devices and the OS
    -  developers communicate with hardware through this

- `Win32k.sys` >> Windowing and Graphics System
    -  GUI tasks & ndering visual elements on screen

## Widows API Call Flow
- Win APIs
    - Win APIs >> they are functions reside in certain .DLL to do specific tasks
        - The following **all functions** are in `kernel32.dll` and `user32.dll`:
        - `kernel32.dll` → core system & memory functions
        - `user32.dll` ->  GUI-related functions (like windows, buttons, message boxes)
        - **Behind the scenes, they call ntdll.dll, which makes syscalls into the kernel.**
        -
            - `CreateFile`	    >> Opens/creates a file or device
            - `ReadFile`	    >> Reads data from a file
            - `WriteFile`	    >> Writes data to a file
            - `CreateProcess`     >> Starts a new process
            - `VirtualAlloc`      >> Allocates memory in a process
            - `ReadProcessMemory` >> Reads memory from another process
            - `MessageBox`	    >> Shows a message box (GUI)
            - `GetModuleHandle`	>> Gets handle to a loaded module (like DLL)
            - `LoadLibrary`       >> Loads a DLL into memory
            - `ExitProcess`	    >> Ends a process

- Flow Example:
    ![Alt text](https://github.com/oybek-turaev-cyber/HTB-CDSA-Prep/blob/main/SOC-Path/Malware_Analysis/pic2.webp)

- Call Function: Understanding
    - when you call a function, it has some required params
    - `  BOOL ReadProcessMemory(`
    -   `HANDLE  hProcess,              // [in] Handle to the target process`
    -   `LPCVOID lpBaseAddress,         // [in] Memory Address to read from (in target process)`
    -   `LPVOID  lpBuffer,              // [out] Buffer in your process to store the data from the target`
    -   `SIZE_T  nSize,                 // [in] Number of bytes to read`
    -   `SIZE_T  *lpNumberOfBytesRead   // [out] How many bytes were actually read );`

- Flow Explanation:
    1. The function `ReadProcessMemory` is called inside `kernel32.dll`
    2. This WinAPI is bridge for us to go to `Kernel Mode`
    3. `kernel32.dll` internally interacts with `NTDLL.DLL`
    4. Then this function request triggers corresponding `syscall`
    5. Then kernel >> *performs necessary validations, access checks*
    6. Then in `Syscall Table`, this syscall finds its pointer
    7. This pointer points to `Native API` function in Kernel
    8. This is `NtReadVirtualMemory` from Kernel Function
        - Kernel Functions & Native API start with `Nt`
    9. Then this `NtReadVirtualMemory` >> *retrieves physical memory pages corresponding to the requested virtual addresses*
    10. Then it *copies the data into the provided buffer.*
    11. Then kernel finishes the job, then transitions back to user-mode application
    12. Voila, the application now finally reads the data from the target processes



## Portable Executable Format
- PE >> is a **format** to encapsulate `executable programs`, `DLLs`, and `other integral system components`
    - Its structure gives *insights into the executable's structure, operations, and potential malign activities embedded within the file.*
    - PE is a data structure >> to provide vital info for
      **Windows OS loader to manage the executable code, effectively loading it into memory.**

- PE Files:
    - different data types:
        -   `.exe, kernel modules(.srv), control panel application (.cpl)`

- PE Sections:
    - `.text` >> often under scrutiny for `potential artifacts related to injection attacks.`

    - `Text Section (.text)`: The hub where the executable code of the program resides.
    - `Data Section (.data)`: A storage for initialized global and static data variables.
    - `Read-only initialized data (.rdata)`: >>
        - Houses read-only data such as constant values, string literals, initialized global and static variables.
    - `Exception information (.pdata)`: A collection of function table entries utilized for exception handling.
    - `BSS Section (.bss)`: Holds uninitialized global and static data variables.
    - `Resource Section (.rsrc)`: Safeguards resources such as images, icons, strings, and version information.
    - `Import Section (.idata)`: Details about functions imported from other DLLs.
    - `Export Section (.edata)`: Information about functions exported by the executable.
    - `Relocation Section (.reloc)`: Details for relocating the executable's code and data when loaded at a different memory address.

    - Visualization Tool >> **pestudio**

## Processes
- Key Info
    - `a process` is an instance of an executing program
    - represents a slice of a program's execution in memory
    - each process has: `memory, file handles, threads, and security contexts.`

- Characteristics:
    1. Unique `PID`

    2. `VAS` (Virtual Address Space) >> dedicated virtual memory for each process
        -  VAS is sectioned into segments: `code, data, and stack segments, allowing the process isolated memory access`
    - How **VAS** is handled?
        - so each process has its own virtual memory
        - that's handled by OS
        - OS handles this using MMU >> Memory Management Unit
            - How OS handles it >> it creates a `map` of big space
            - this bag space is `RAM + DISC` >> this makes storage base of VAS
            - **disk (via paging or swap file) when RAM is full**
                - *This makes VAS seem much larger than actual RAM!*
            - then in this map, it has `virtual addresses` >> later these
            - virtual addresses are translated to `physical addresses` at the end of the day
                - this job is done by MMU
        - In short >> *Virtual space is a map made by the OS.*
        - **Real data is stored in RAM or disk, and the MMU figures out where exactly.**

    3. `Executable Code` >> Image File on Disk
        - binary executable file stored on the disk

    4. `Table of Handles to System Objects`
        - Processes maintain a table of handles, *a reference catalogue for various system objects*
        - System objects can span files, devices, registry keys, synchronization objects, and other resources.

    5. `Security Context (Access Token):`
        - each process has security context >> **embodied by an Access Token**
        - this `access token` has encapsulated all privileges, user account

    6. `One or More Threads Running in its Context`
        - Processes consist of one or more threads
        - A thread is the smallest unit of execution inside a process.
        - **Threads enable concurrent execution &&  facilitate multitasking.**
        - **threads >> they are workers inside this one process**

## DLL
- What is DLL?
    - `Microsoft's implementation of the shared library concept in the Microsoft Windows OS`
    - DLLs expose an array of functions
    - there are *import and export functions in a DLL*
    - **these funtions will be injected by attackers**

    - Import Functions
        -
        - coming from external library or modules during *runtime*
        - enable the binary to leverage the functionalities offered by these libraries.
        -
        - Why we care?:
            - *examining import functions may shed light on the external libraries or modules that the malware is dependent on*
            - *identifying the APIs that the malware might interact with, and also the resources such as the file system, processes, registry*
            - *Import function names or hashes can serve as IOCs*
            -
        - Imported Functions can be examined by the tool: **CFF Explorer**

    - Example Scenario:
        -
        - Malware `shell.exe` injects code into `notepad.exe` using `kernel32.dll APIs`:
            - `OpenProcess` – Gets a handle(a special access key to a system object) to `notepad.exe` with required access.
            - `VirtualAllocEx` – Allocates memory inside `notepad.exe.`
            - `WriteProcessMemory` – Writes `shellcode` into that memory.
            - `CreateRemoteThread` – Starts a new thread in `notepad.exe` to `run the shellcode.`
            -
        - **handle** >> *A reference (ID) given by the OS to access an object (like a process, file, thread*

    - Export Functions:
        - functions that a binary exposes for use by other modules or applications.
        - can be viewed by **CFF Explorer or Debugger: x64dbg - Symbols tab**

## Practical Challenges:
1.  In the C:\Samples\MalwareAnalysis directory of this section's target, there is a file called potato.exe.
    Use pestudio (C:\Tools\pestudio\pestudio) to examine this executable's sections and
    provide the entropy of the .text section as your answer.


    **Solved:**
    - J'ai utilise cet outil pour ouvrir le fichier: pestudio
    - Apres, j'ai trouve la section dont je peux voir le contenu .text
    - Et voila, j'ai obtenu le drapeau

2.  In the C:\Samples\MalwareAnalysis directory of this section's target, there is a file called potato.exe.
    Use x64dbg (C:\Tools\x64dbg\release\x64) to open this executable and navigate to the Symbols tab.
    Enter the exported Kernel32.dll function whose name starts with "Attach". Answer format: Attach_

    **Solved:**
    - J'ai utilise cet outil: x64dbg debugger
    - Apres, j'ai cherche le mot dans le filter de TAB Symbols: 'Attach'
    - Et Voila, j'ai trouve le drapeau
















